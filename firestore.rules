/**
 * @file Firestore Security Rules for Okidex Platform
 * @description This ruleset enforces a multi-tenant security model where users can only access their own data,
 * with specific exceptions for public content and collaborations.
 *
 * Data Structure:
 * - /users/{userId}: User accounts, accessible only by the owning user.
 * - /user_profiles/{profileId}: User profile information, accessible only by the owning user. profileId must match userId.
 * - /matches/{matchId}: Matches between users. Only users involved in the match can access the match document.
 * - /matches/{matchId}/messages/{messageId}: Messages between matched users.  Only users in the match can access messages.
 * - /job_postings/{jobPostingId}: Job postings created by founders, publicly readable.
 * - /investment_opportunities/{investmentOpportunityId}: Investment opportunities, publicly readable.
 * - /investment_theses/{investmentThesisId}: Investment theses posted by investors.
 * - /financial_summaries/{financialSummaryId}: Financial summaries for investment opportunities.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect user privacy.
 * - Public read access is granted to /job_postings and /investment_opportunities, but write access is restricted to authenticated users.
 * - The ruleset prioritizes authorization independence through data denormalization to avoid complex queries.
 *
 * Denormalization for Authorization:
 * - /matches/{matchId}/messages/{messageId} includes senderId and receiverId for efficient authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user accounts, ensuring only the authenticated user can access their own document.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their own account.
     * @allow (get) User with ID 'user123' can read their own account.
     * @allow (update) User with ID 'user123' can update their own account.
     * @allow (delete) User with ID 'user123' can delete their own account.
     * @deny (create) User with ID 'user456' cannot create an account with ID 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secures user profiles, ensuring only the authenticated user can access their own profile.
     * @path /user_profiles/{profileId}
     * @allow (create) User with profile ID 'profile123' can create their profile.
     * @allow (get) User with profile ID 'profile123' can read their profile.
     * @allow (update) User with profile ID 'profile123' can update their profile.
     * @allow (delete) User with profile ID 'profile123' can delete their profile.
     * @deny (create) User with profile ID 'profile456' cannot create a profile with ID 'profile123'.
     * @principle Enforces document ownership for all operations.
     */
    match /user_profiles/{profileId} {
      function isOwnerProfile(profileId) {
        return request.auth != null && request.auth.uid == profileId;
      }
      allow get: if isOwnerProfile(profileId);
      allow list: if false;
      allow create: if request.auth.uid == profileId;
      allow update: if isOwnerProfile(profileId);
      allow delete: if isOwnerProfile(profileId);
    }

    /**
     * @description Secures matches between users, ensuring only matched users can access the match document.
     * @path /matches/{matchId}
     * @allow (get) User 'user123' can read a match document where they are either user1 or user2.
     * @allow (create) User 'user123' can create a match document if the appropriate validation is in place.
     * @deny (get) User 'user456' cannot read a match document where they are not user1 or user2.
     * @principle Enforces shared access based on user inclusion in the match.
     */
    match /matches/{matchId} {
        function isParticipant(matchId) {
            return get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid;
        }

        function canCreateMatch() {
            return request.auth != null && (request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid);
        }

      allow get: if request.auth != null && isParticipant(matchId);
      allow list: if false;
      allow create: if request.auth != null && (request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid);
      allow update: if request.auth != null && isParticipant(matchId);
      allow delete: if false;
    }

    /**
     * @description Secures messages between matched users, ensuring only users involved in the match can access the messages.
     * @path /matches/{matchId}/messages/{messageId}
     * @allow (create) User 'user123' can create a message if they are the sender.
     * @allow (get) User 'user123' can read a message if they are either the sender or receiver.
     * @deny (create) User 'user456' cannot create a message in a match they are not part of.
     * @principle Enforces shared access to messages based on user inclusion in the parent match.
     */
    match /matches/{matchId}/messages/{messageId} {
        function isSenderOrReceiver() {
            return request.auth != null && (request.resource.data.senderId == request.auth.uid || request.resource.data.receiverId == request.auth.uid);
        }

        function isInMatch(matchId) {
            return get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid;
        }

      allow get: if request.auth != null && isInMatch(matchId);
      allow list: if false;
      allow create: if request.auth != null && request.resource.data.senderId == request.auth.uid && isInMatch(matchId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secures job postings, allowing public read access and authenticated-user-only write access.
     * @path /job_postings/{jobPostingId}
     * @allow (get) Any user can read any job posting.
     * @allow (list) Any user can list job postings.
     * @allow (create) Authenticated user 'founder123' can create a job posting.
     * @deny (create) Anonymous user cannot create a job posting.
     * @principle Public read access with owner-only writes.
     */
    match /job_postings/{jobPostingId} {
      function isSignedIn() {
        return request.auth != null;
      }

        function isOwner(jobPostingId) {
            return get(/databases/$(database)/documents/job_postings/$(jobPostingId)).data.founderId == request.auth.uid;
        }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.founderId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(jobPostingId);
      allow delete: if isSignedIn() && isOwner(jobPostingId);
    }

    /**
     * @description Secures investment opportunities, allowing public read access and authenticated-user-only write access.
     * @path /investment_opportunities/{investmentOpportunityId}
     * @allow (get) Any user can read any investment opportunity.
     * @allow (list) Any user can list investment opportunities.
     * @allow (create) Authenticated user 'founder123' can create an investment opportunity.
     * @deny (create) Anonymous user cannot create an investment opportunity.
     * @principle Public read access with owner-only writes.
     */
    match /investment_opportunities/{investmentOpportunityId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(investmentOpportunityId) {
        return get(/databases/$(database)/documents/investment_opportunities/$(investmentOpportunityId)).data.founderId == request.auth.uid;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.founderId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(investmentOpportunityId);
      allow delete: if isSignedIn() && isOwner(investmentOpportunityId);
    }

    /**
     * @description Secures investment theses, ensuring only authenticated investors can create them.
     * @path /investment_theses/{investmentThesisId}
     * @allow (create) Authenticated user 'investor123' can create an investment thesis.
     * @allow (get) Any user can read any investment thesis.
     * @deny (create) Anonymous user cannot create an investment thesis.
     * @principle Authenticated users can create, and any user can read.
     */
    match /investment_theses/{investmentThesisId} {
        function isSignedIn() {
            return request.auth != null;
        }
        function isOwner(investmentThesisId) {
          return get(/databases/$(database)/documents/investment_theses/$(investmentThesisId)).data.investorId == request.auth.uid;
        }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.investorId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(investmentThesisId);
      allow delete: if isSignedIn() && isOwner(investmentThesisId);
    }

    /**
     * @description Secures financial summaries, ensuring only authorized users can access them.
     * @path /financial_summaries/{financialSummaryId}
     * @allow (get) Any user can read a financial summary.
     * @deny (create) Anonymous user cannot create a financial summary.
     * @principle Requires authorization to create and secure data.
     */
    match /financial_summaries/{financialSummaryId} {
        function isOwner(financialSummaryId) {
            return get(/databases/$(database)/documents/financial_summaries/$(financialSummaryId)).data.ownerId == request.auth.uid;
        }
      allow get: if true;
      allow list: if true;
      allow create: if request.auth != null; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if request.auth != null && isOwner(financialSummaryId); // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if request.auth != null && isOwner(financialSummaryId); // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}
