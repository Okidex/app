/**
 * @fileoverview Firestore Security Rules for Okidex Platform
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-related data
 * and role-based access for other resources like job postings and investment opportunities.
 * The rules prioritize security and data isolation, ensuring users can only
 * access their own data while also enabling controlled sharing and access based on user roles.
 *
 * Data Structure:
 * - /users/{userId}: Stores user accounts; access is restricted to the owning user.
 * - /user_profiles/{profileId}: Stores user profiles; access is restricted to the owning user.
 * - /matches/{matchId}: Stores matches between users; access is restricted to the matched users.
 * - /matches/{matchId}/messages/{messageId}: Stores messages; access is restricted to users in the match.
 * - /job_postings/{jobPostingId}: Stores job postings; access is restricted based on user roles (founders can create, talent can view).
 * - /investment_opportunities/{investmentOpportunityId}: Stores investment opportunities; access is restricted based on user roles (founders can create, investors can view).
 * - /investment_theses/{investmentThesisId}: Stores investment theses; access is restricted to investors.
 * - /financial_summaries/{financialSummaryId}: Stores financial summaries; access is restricted to authorized users (e.g., investors).
 *
 * Key Security Decisions:
 * - User listing is implicitly disallowed by the data structure. All user-related data is stored under the /users/{userId} path, preventing unauthorized access to user information.
 * - Write permissions are always validated against the authenticated user's identity (`request.auth.uid`).
 *
 * Denormalization for Authorization:
 * - The /matches/{matchId}/messages/{messageId} path includes denormalized senderId and receiverId fields to authorize access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user accounts. Only the authenticated user can access their own document.
     * @path /users/{userId}
     * @allow (create) - An authenticated user can create their own user document if the userId matches their auth UID.
     * @allow (get, update, delete) - An authenticated user can get, update, or delete their own user document.
     * @deny (create) - An unauthenticated user cannot create a user document.
     * @deny (get, update, delete) - An authenticated user cannot access another user's document.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data.id == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to user profiles. Only the authenticated user can access their own profile.
     * @path /user_profiles/{profileId}
     * @allow (create) - An authenticated user can create their own profile if the profileId matches the desired ID.
     * @allow (get, update, delete) - An authenticated user can get, update, or delete their own profile.
     * @deny (create) - An unauthenticated user cannot create a profile.
     * @deny (get, update, delete) - An authenticated user cannot access another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /user_profiles/{profileId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Controls access to matches between users. Only the matched users can access the match document.
     * @path /matches/{matchId}
     * @allow (get, list) - Only matched users can access.
     * @allow (create) - Authenticated users can create matches.
     * @allow (update, delete) - Only the matched users can update/delete the match document.
     * @deny (create) - An unauthenticated user cannot create a match.
     * @deny (get, update, delete) - An authenticated user cannot access another user's match document.
     * @principle Enforces access control based on user involvement in the match.
     */
    match /matches/{matchId} {
      function isSignedIn() {
        return request.auth != null;
      }
       function isParticipant(match) {
          return isSignedIn() && (request.auth.uid == match.user1Id || request.auth.uid == match.user2Id);
      }
        function isExistingParticipant() {
          return isSignedIn() && (resource.data.user1Id == request.auth.uid || resource.data.user2Id == request.auth.uid);
      }
      allow get: if isExistingParticipant();
      allow list: if false;
      allow create: if isSignedIn() && (request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid);
      allow update: if isExistingParticipant();
      allow delete: if isExistingParticipant();
    }

    /**
     * @description Controls access to messages between matched users.
     * @path /matches/{matchId}/messages/{messageId}
     * @allow (get, list) - Only users involved in the match can access messages.
     * @allow (create) - Only users involved in the match can create messages. The senderId must match the authenticated user's ID.
     * @allow (update, delete) - Only the sender can update/delete their own messages.
     * @deny (create) - An unauthenticated user cannot create a message.
     * @deny (get, update, delete) - An authenticated user cannot access messages in another user's match.
     * @principle Enforces access control based on user involvement in the match, leveraging denormalized senderId and receiverId fields.
     */
    match /matches/{matchId}/messages/{messageId} {
        function isSignedIn() {
          return request.auth != null;
        }
         function isParticipant(message) {
            return isSignedIn() && (message.senderId == request.auth.uid || message.receiverId == request.auth.uid);
        }
          function isExistingParticipant() {
            return isSignedIn() && (resource.data.senderId == request.auth.uid || resource.data.receiverId == request.auth.uid);
        }
      allow get: if isExistingParticipant();
      allow list: if isExistingParticipant();
      allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.senderId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.senderId == request.auth.uid;
    }

    /**
     * @description Controls access to job postings. Authenticated users can create job postings, and all authenticated users can view them.
     * @path /job_postings/{jobPostingId}
     * @allow (get, list) - All authenticated users can read job postings.
     * @allow (create) - Only authenticated users can create job postings, and the founderId must match their UID.
     * @allow (update, delete) - Only the creator (founder) can update or delete.
     * @deny (create) - An unauthenticated user cannot create a job posting.
     * @deny (update, delete) - An authenticated user cannot modify or delete another user's job posting.
     * @principle Enforces creator-only writes with public reads.
     */
    match /job_postings/{jobPostingId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(founderId) {
          return isSignedIn() && request.auth.uid == founderId;
      }
       function isExistingOwner() {
        return isSignedIn() && resource.data.founderId == request.auth.uid;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.founderId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to investment opportunities. Authenticated users can create investment opportunities, and all authenticated users can view them.
     * @path /investment_opportunities/{investmentOpportunityId}
     * @allow (get, list) - All authenticated users can read investment opportunities.
     * @allow (create) - Only authenticated users can create investment opportunities, and the founderId must match their UID.
     * @allow (update, delete) - Only the creator (founder) can update or delete.
     * @deny (create) - An unauthenticated user cannot create an investment opportunity.
     * @deny (update, delete) - An authenticated user cannot modify or delete another user's investment opportunity.
     * @principle Enforces creator-only writes with public reads.
     */
    match /investment_opportunities/{investmentOpportunityId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(founderId) {
          return isSignedIn() && request.auth.uid == founderId;
      }
        function isExistingOwner() {
        return isSignedIn() && resource.data.founderId == request.auth.uid;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.founderId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to investment theses. Only investors can create them.
     * @path /investment_theses/{investmentThesisId}
     * @allow (get, list) - All authenticated users can read investment theses.
     * @allow (create) - Only authenticated investors can create. The investorId must match their UID.
     * @allow (update, delete) - Only the creator (investor) can update or delete.
     * @deny (create) - An unauthenticated user cannot create an investment thesis.
     * @deny (update, delete) - An authenticated user cannot modify or delete another user's investment thesis.
     * @principle Enforces creator-only writes with public reads.
     */
    match /investment_theses/{investmentThesisId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(investorId) {
          return isSignedIn() && request.auth.uid == investorId;
      }
      function isExistingOwner() {
        return isSignedIn() && resource.data.investorId == request.auth.uid;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.investorId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to financial summaries. Only authorized users (e.g., investors) can access the financial summaries associated with InvestmentOpportunity documents they have access to.
     * @path /financial_summaries/{financialSummaryId}
     * // TODO: Implement rules once the authorization logic is fully defined.
     * @allow (get, list, create, update, delete) - No access.
     * @principle Restricts access to financial summaries based on investment opportunity access.
     */
    match /financial_summaries/{financialSummaryId} {
        function isSignedIn() {
          return request.auth != null;
        }
      allow get: if isSignedIn() && resource.data.investorId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.investorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.investorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.investorId == request.auth.uid;
      // TODO: Add owner validation once the schema is updated with an ownership field or tie it to the parent /investment_opportunities/{investmentOpportunityId}
    }
  }
}
